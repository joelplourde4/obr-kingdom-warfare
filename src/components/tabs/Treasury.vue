<template>
    <p v-if="domain.realm.provinces.length === 0">To get started, right-click on a drawing and select the option to add it as a province.</p>
    <div class="content">
        <div class="treasury row">
            <h3>Treasury:</h3>
            <div class="tooltip">
                <h3>{{ treasury }}</h3>
                <span class="tooltiptext">The present amount in the Kingdom's Treasury.</span>
            </div>
            <div class="tooltip">
            <h3 :style=" { 'color': forecast >= 0 ? 'var(--text-accent)': 'red'} ">({{ forecast }})</h3>
                <span class="tooltiptext">The resources that will be added to or subtracted from the treasury during the next domain turn.</span>
            </div>
        </div>
        <button v-if="domain.realm.provinces.length > 0" type="button" class="collapsible column" @click="openProvinceCollapsible">
            <div class="label">
                <h3 v-if="domain.realm.provinces.length > 0">Provinces</h3>
                <h3 class="number">({{ domain.realm.provinces.length }})</h3>
            </div>
            <div class="sub-total">
                <div class="tooltip">
                    <h3 class="production">{{ provinceTotal }}</h3>
                    <span class="tooltiptext">The sum of the profit generated by your provinces.</span>
                </div>
                <div class="caret">
                    <img v-if="showProvinces" src="/caret-up.svg">
                    <img v-if="!showProvinces" src="/caret-down.svg">
                </div>
            </div>
        </button>
        <div v-show="showProvinces">
            <table class="province-table">
                <tr v-if="domain.realm.provinces.length > 0">
                    <th>Terrain</th>
                    <th>Population</th>
                    <th>Production</th>
                    <th>Profit</th>
                </tr>
                <tr v-for="province in domain.realm.provinces">
                    <td>
                        <div class="tooltip">
                            <select class="dropdown" v-model="province.terrain" @click="preventPropagation" @change="onChanges" :disabled="isDisabled">
                                <option v-for="terrain in Terrain" :value="terrain">
                                    {{ terrain }}
                                </option>
                            </select>
                            <span class="tooltiptext">Terrain refers to the kind of land found in the province.</span>
                        </div>
                    </td>
                    <td>
                        <div class="tooltip">
                            <select class="dropdown" v-model="province.populationCenter" @click="preventPropagation" @change="onChanges" :disabled="isDisabled">
                                <option v-for="populationCenter in availablePopulationCenter" :value="populationCenter">
                                    {{ populationCenter }}
                                </option>
                            </select>
                            <span class="tooltiptext">Population centers are settlements ranging from small thorpes to large metropolises. Each province can have one population center, which enables resource extraction.</span>
                        </div>
                    </td>
                    <td>
                        <div class="production-container">
                            <div class="tooltip">
                                <p class="production">+{{ computeProvinceProduction(domain.realm, province) }}</p>
                                <span class="tooltiptext">Larger population centers generate more resources by effectively utilizing the land.</span>
                            </div>
                            <div class="tooltip">
                            <p class="upkeep">({{ computeProvinceUpkeep(domain.realm, province) }})</p>
                                <span class="tooltiptext">Population centers require upkeep for maintenance, services, and salaries.</span>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="tooltip">
                            <p>{{ computeProvinceProfit(province) }}</p>
                            <span class="tooltiptext">Profit is calculated by subtracting the province's upkeep costs from its total revenue.</span>
                        </div>
                    </td>
                </tr>
            </table>
            <div class="modifier">
                <p>Governance Production Modifier:</p>
                <p class="production modifier-number">{{ governingStyleProductionModifier }}%</p>
            </div>
            <div class="modifier">
                <p>Governance Upkeep Modifier:</p>
                <p class="production modifier-number">{{ governingStyleUpkeepModifier }}%</p>
            </div>
            <div class="modifier">
                <p>Civilization Production Modifier:</p>
                <p class="production modifier-number">{{ civilizationProductionModifier }}%</p>
            </div>
            <div class="modifier">
                <p>Civilization Upkeep Modifier:</p>
                <p class="production modifier-number">{{ civilizationUpkeepModifier }}%</p>
            </div>
        </div>
        <button v-if="domain.units.length > 0" type="button" class="collapsible column" @click="openUnitCollapsible">
            <div class="label">
                <h3 v-if="domain.units.length > 0">Units</h3>
                <h3 class="number">({{ domain.units.length }})</h3>
            </div>
            <div class="sub-total">
                <div class="tooltip">
                    <h3 class="upkeep">{{ unitTotal }}</h3>
                    <span class="tooltiptext">The sum of the upkeep of your units.</span>
                </div>
                <div class="caret">
                    <img v-if="showUnits" src="/caret-up.svg">
                    <img v-if="!showUnits" src="/caret-down.svg">
                </div>
            </div>
        </button>
        <div v-show="showUnits">
            <table class="unit-table">
                <tr v-if="domain.units.length > 0">
                    <th>Name</th>
                    <th>Upkeep</th>
                </tr>
                <tr v-for="unit in domain.units">
                    <td>
                        <div class="tooltip">
                            <p>{{ unit.name }}</p>
                            <span class="tooltiptext">The name of the unit.</span>
                        </div>
                    </td>
                    <td>
                        <div class="tooltip">
                            <p>{{ unit.upkeep }}</p>
                            <span class="tooltiptext">The upkeep is 25% of its current total cost of the unit, which includes the base cost plus any added value from experience, type, traits, and equipment.</span>
                        </div>
                    </td>
                </tr>
            </table>
            <div class="modifier">
                <p>Unit Cost Reduction:</p>
                <p class="production modifier-number">{{ unitCostModifier }}%</p>
            </div>
        </div>
    </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { utils } from '../../mixins/utils'

import BaseTab from './BaseTab.ts'
import OBR, { ContextMenuContext, Player } from '@owlbear-rodeo/sdk';
import { Heritage, Civilization, GoverningStyle, PopulationCenter, Province, Realm, Terrain, POPULATION_CENTER_UPKEEP, GOVERNING_STYLE_PRODUCTION_MODIFIER, POPULATION_CENTER_PRODUCTION_MODIFIER, HERITAGE_TERRAIN_MODIFIER, CIVILIZATION_PRODUCTION_MODIFIER, CIVILIZATION_POPULATION_CENTER_UPKEEP_MODIFIER, UNIT_COST_GOVERNING_STYLE_NOBLE_MODIFIER, UNIT_COST_CIVILIZATION_BARBARIC_MODIFIER, UNIT_COST_CIVILIZATION_NOMADIC_MODIFIER, GOVERNING_STYLE_NONE_PROVINCE_UPKEEP_MODIFIER, GOVERNING_STYLE_PROVINCE_UPKEEP } from '../../models/Realm.ts';
import { Config } from '../../models/Config.ts';

const ID = "com.obr.domain-sheet/treasury"

const TREASURY_METADATA_KEY = ID + "/metadata";
const OWNER_METADATA_KEY = ID + "/owner";

export default defineComponent({
    mixins: [utils],
    extends: BaseTab,
    name: 'Treasury',
    props: {
        config: {
            type: Config,
            required: true
        },
        currentPlayer: {
            type: Object as PropType<Player>,
            required: true
        },
        players: {
            type: Array<Player>,
            required: true,
        }
    },
    data() {
        let sceneItemChangeCallback = () => {};
        let sceneMetadataCallback = () => {};
        return {
            /** Collapsible */
            showProvinces: false,
            showUnits: false,

            /** In-between data */
            provinceTotal: 0,
            unitTotal: 0,
            civilizationProductionModifier: 0,
            governingStyleProductionModifier: 0,
            civilizationUpkeepModifier: 0,
            governingStyleUpkeepModifier: 0,
            unitCostModifier: 0,

            /** Data Map */
            POPULATION_CENTER_UPKEEP,
            GOVERNING_STYLE_PRODUCTION_MODIFIER,
            HERITAGE_TERRAIN_MODIFIER,
            CIVILIZATION_PRODUCTION_MODIFIER,
            CIVILIZATION_POPULATION_CENTER_UPKEEP_MODIFIER,

            /** Enums */
            Terrain,
            Heritage,
            Civilization,
            GoverningStyle,
            PopulationCenter,

            /** Functions */
            sceneItemChangeCallback,
            sceneMetadataCallback
        }
    },
    created() {
        // If the previous load file did not contain the Realm, add it.
        if (!this.domain.realm) {
            this.domain.realm = new Realm();
        }
    },
    mounted() {
        const obrIntervalId = window.setInterval(async () => {
            if (OBR.isReady) {
                OBR.contextMenu.create(this.buildContextMenu());
                clearInterval(obrIntervalId);
            }
        }, 200);

        const sceneIntervalId = window.setInterval(async () => {
            const isReady = await OBR.scene.isReady();
            if (isReady) {
                this.sceneItemChangeCallback = OBR.scene.items.onChange((items) => {
                    if (this.config.sharedMode) {
                        return;
                    }

                    const drawings = items.filter((item) => item.layer == "DRAWING");

                    // Scan all of your province to make sure they still have that metadata tag, if not remove that province, another player claimed it.
                    let hasChanged = false;
                    for (let province of this.domain.realm.provinces) {

                        let found = false;
                        for (let drawing of drawings) {
                            if (drawing.metadata[OWNER_METADATA_KEY] === this.currentPlayer.id) {
                                found = true;
                                break;
                            }
                        }

                        if (!found) {
                            this.domain.realm.provinces = this.domain.realm.provinces.filter((x) => x.id !== province.id);
                            hasChanged = true;
                        }
                    }

                    if (hasChanged) {
                        this.updateRealm(this.domain.realm);
                    }
                });

                clearInterval(sceneIntervalId);
            }
        }, 200);
    },
    unmounted() {
        this.sceneItemChangeCallback();
        this.sceneMetadataCallback();
    },
    computed: {
        treasury() {
            return this.domain.realm.treasury || 0;
        },
        forecast() {
            const governingStyleProductionModifier = GOVERNING_STYLE_PRODUCTION_MODIFIER.get(this.domain.realm.governingStyle) || 1.0;
            const governingStyleUpkeepModifier = GOVERNING_STYLE_PROVINCE_UPKEEP.get(this.domain.realm.governingStyle) || 1.0;
            const civilizationUpkeepModifier = CIVILIZATION_POPULATION_CENTER_UPKEEP_MODIFIER.get(this.domain.realm.civilization) || 1.0;
            const civilizationProductionModifier = CIVILIZATION_PRODUCTION_MODIFIER.get(this.domain.realm.civilization) || 1.0;

            let profit = 0;
            for (let province of this.domain.realm.provinces) {
                profit += province.profit;
            }
            
            // Upkeep from the Units.
            let upkeep = 0;
            for (let unit of this.domain.units) {
                // A unit’s upkeep is equal to 25% of the cost of the unit’s current value
                upkeep += unit.upkeep;
            }

            let unitCostMod = 1;
            if (this.domain.realm.governingStyle == GoverningStyle.NOBLE) {
                unitCostMod *= UNIT_COST_GOVERNING_STYLE_NOBLE_MODIFIER;
            }

            if (this.domain.realm.civilization == Civilization.BARBARIC) {
                unitCostMod *= UNIT_COST_CIVILIZATION_BARBARIC_MODIFIER;
            }

            if (this.domain.realm.civilization == Civilization.NOMADIC) {
                unitCostMod *=  UNIT_COST_CIVILIZATION_NOMADIC_MODIFIER;
            }

            this.provinceTotal = Math.round(profit);
            this.unitTotal = Math.round(upkeep);

            this.governingStyleProductionModifier = -Math.round((1 - governingStyleProductionModifier) * 100);
            this.governingStyleUpkeepModifier = -Math.round((1 - governingStyleUpkeepModifier) * 100);
            this.civilizationProductionModifier = - Math.round((1 - civilizationProductionModifier) * 100);
            this.civilizationUpkeepModifier = -Math.round((1 - civilizationUpkeepModifier) * 100);
            this.unitCostModifier = Math.round((1 - unitCostMod) * 100);

            return Math.round(profit - upkeep);
        },
        /**
         * Compute what are the available population center based on the Kingdom's civilization
         */
        availablePopulationCenter() {
            const nomads = [PopulationCenter.SMALL_CAMP, PopulationCenter.MEDIUM_CAMP, PopulationCenter.LARGE_CAMP]
            if (this.domain.realm.civilization == Civilization.NOMADIC) {
                return nomads;
            }

            return Object.values(PopulationCenter).filter(
                (center) => !nomads.includes(center)
            );
        }
    },
    methods: {
        onChanges() {
            this.onUpdate();
        },
        /**
         * Update the realm
         */
        updateRealm(_realm: Realm) {
            this.onUpdate();
        },
        /**
         * Add the province to the Realm
         * @param context
         */
        addProvinceToRealm(context: ContextMenuContext) {
            // Update the Hex in the scene.
            OBR.scene.items.updateItems(context.items, (items) => {
                for (let item of items) {
                    if (item.metadata[TREASURY_METADATA_KEY] === undefined) {
                        const province = new Province(item.id);
                        province.color = this.currentPlayer.color;
                        this.domain.realm.provinces.push(province);

                        item.style.fillColor = this.currentPlayer.color;
                        item.style.strokeColor = this.currentPlayer.color;
                        item.style.fillOpacity = 0.10;
                        item.style.strokeOpacity = 1;
                        item.metadata = {
                            [OWNER_METADATA_KEY]: this.currentPlayer.id
                        };
                    }

                    item.metadata[TREASURY_METADATA_KEY] = {
                        key: item.id
                    };
                }

                this.updateRealm(this.domain.realm);
            });
        },
        /**
         * Method to remove a provice from the realm when the user click on 'Remove Province' in the scene.
         * @param context The context
         */
         removeProvinceFromRealm(context: ContextMenuContext) {
            OBR.scene.items.updateItems(context.items, (items) => {
                for (let item of items) {
                    if (item.metadata[TREASURY_METADATA_KEY] !== undefined) {
                        this.domain.realm.provinces = this.domain.realm.provinces.filter((x: Province) =>
                            x.id !== item.id
                        );

                        item.style.fillColor = "#000000";
                        item.style.strokeColor = "#000000";
                        item.style.fillOpacity = 0.10;
                        item.style.strokeOpacity = 1;
                        item.metadata = {
                            [OWNER_METADATA_KEY]: undefined
                        };

                        delete item.metadata[TREASURY_METADATA_KEY];
                    }
                }

                this.updateRealm(this.domain.realm);
            });
        },
         /**
         * Event triggered whenever the context menu gets clicked.
         * @param context  The context menu context
         * @param _elementId The element
         */
         onContextMenuClick(context: ContextMenuContext, _elementId: string) {
            const addToRealm = context.items.every(
                (item) => item.metadata[TREASURY_METADATA_KEY] === this.player
            );
            if (addToRealm) {
                this.addProvinceToRealm(context);
            } else {
                this.removeProvinceFromRealm(context);
            }
        },
        /**
         * Build the context menu to be right-clicked.
         */
         buildContextMenu() {
            return {
                id: ID,
                icons: [
                    {
                        icon: "/pin.svg",
                        label: "Claim Province",
                        filter: {
                            every: [
                                { key: "visible", value: true },
                                { key: "layer", value: "DRAWING" },
                                { key: ["metadata", TREASURY_METADATA_KEY], value: undefined }
                            ]
                        }
                    },
                    {
                        icon: "/pin.svg",
                        label: "Remove Province",
                        filter: {
                            every: [
                                { key: "visible", value: true },
                                { key: "layer", value: "DRAWING" },
                            ]
                        }
                    }
                ],
                onClick: this.onContextMenuClick
            }
        },
        computeProvinceUpkeep(realm: Realm, province: Province): number {
            // Base upkeep.
            let upkeep =  POPULATION_CENTER_UPKEEP.get(province.populationCenter) || 0;
            upkeep *= CIVILIZATION_POPULATION_CENTER_UPKEEP_MODIFIER.get(realm.civilization) || 1.0;
            upkeep *= GOVERNING_STYLE_PROVINCE_UPKEEP.get(realm.governingStyle) || 1.0;
            province.upkeep = Math.round(upkeep);
            return province.upkeep;
        },
        computeProvinceProduction(realm: Realm, province: Province): number {
            // Based on the Terrain, get the base production of the province.
            const terrainModifiers = HERITAGE_TERRAIN_MODIFIER.get(realm.heritage);
            const terrainModifier = terrainModifiers?.get(province.terrain) || 0;

            // Based on the Population Center itself, adjust the production.
            const productionModifier = POPULATION_CENTER_PRODUCTION_MODIFIER.get(province.populationCenter) || 0;

            // Based on the Civilization, adjust the production.
            const civiliationModifier = CIVILIZATION_PRODUCTION_MODIFIER.get(realm.civilization) || 1.0;

            const governingStyleProductionModifier = GOVERNING_STYLE_PRODUCTION_MODIFIER.get(this.domain.realm.governingStyle) || 1.0;

            // Calculate the raw values
            let revenue = terrainModifier * productionModifier * this.config.multiplier;

            // Adjust the final modifier
            revenue *= civiliationModifier;
            revenue *= governingStyleProductionModifier;

            province.production = revenue;
            return province.production;
        },
        computeProvinceProfit(province: Province) {
            province.profit = province.production - province.upkeep;
            return province.profit;
        },
        openProvinceCollapsible() {
            this.showProvinces = !this.showProvinces;
        },
        openUnitCollapsible() {
            this.showUnits = !this.showUnits;
        }
    }
})
</script>
  
<style scoped>

p {
   margin: 0;
}

.header {
    justify-content: space-around;
}

.province-table {
    width: 100%;
    margin: auto;
    display: inline-table;

    .production-container {
        display: inline-flex;
    }
}

.unit-table {
    width: 100%;
    margin: auto;
    display: inline-table;
}

.modifier {
    display: flex;
    justify-content: flex-end;

    .modifier-number {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }
}

.treasury {
    justify-content: center;

    h3 {
        margin: 0;
        padding-left: 0.5rem;
    }
}

.production {
    color: var(--text-accent);
}

.upkeep {
    color: red;
    padding-left: 0.0625rem;
}

.collapsible {
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    margin-top: 0.5rem;

    .label {
        padding-left: 1rem;
        display: inline-flex;
        align-items: center;

        .number {
            margin-left: 0.25rem;
        }
    }

    .sub-total {
        display: inline-flex;
        align-items: center;

        .caret {
            filter: invert(80%) sepia(29%) saturate(6341%) hue-rotate(207deg) brightness(100%) contrast(102%);;
        }
    }
}

</style>