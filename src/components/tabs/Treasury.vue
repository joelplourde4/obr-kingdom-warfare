<template>
    <div class="content">
        <Time
            :isGM="isGM"
            :config="config"
            :realm="domain.realm"
            @update:time="onChangeTimeEvent"
        />
        <hr>
        <div class="treasury column">
            <h3>Treasury</h3>
            <div class="row">
                <div class="treasury-amount row">
                    <input 
                        class="treasury-input input-number-value"
                        type="text"
                        v-model="domain.realm.treasury"
                        :disabled="!isEditMode"
                        @change="onTreasuryChanged"
                        @keyup="onTreasuryEnter"
                    />
                    <div class="tooltip">
                        <h3 :style="{ 'color': forecast >= 0 ? 'var(--text-accent)': 'red'}">({{ forecast }})</h3>
                        <span class="tooltiptext">The resources that will be added to or subtracted from the treasury during the next domain turn.</span>
                    </div>
                </div>
            </div>
        </div>
        <button type="button" class="collapsible column" @click="openProvinceCollapsible">
            <div class="label">
                <h3>Provinces</h3>
                <h3 class="number">({{ domain.realm.provinces.length }})</h3>
            </div>
            <div class="sub-total">
                <div class="tooltip">
                    <h3 class="production">{{ provinceProfits }}</h3>
                    <span class="tooltiptext">The sum of the profit generated by your provinces.</span>
                </div>
                <div class="caret">
                    <img v-if="showProvinces" src="/caret-up.svg">
                    <img v-if="!showProvinces" src="/caret-down.svg">
                </div>
            </div>
        </button>
        <div v-show="showProvinces">
            <p v-if="domain.realm.provinces.length === 0">To get started, right-click on a drawing and select the option to add it as a province.</p>
            <table class="province-table">
                <tr v-if="domain.realm.provinces.length > 0">
                    <th>Terrain</th>
                    <th>Population</th>
                    <th>Production</th>
                    <th>Profit</th>
                </tr>
                <tr v-for="province in domain.realm.provinces">
                    <td>
                        <div class="tooltip">
                            <select class="dropdown" v-model="province.terrain" @click="preventPropagation" @change="onChanges" :disabled="!hasPermission">
                                <option v-for="terrain in Terrain" :value="terrain">
                                    {{ terrain }}
                                </option>
                            </select>
                            <span class="tooltiptext">Terrain refers to the kind of land found in the province.</span>
                        </div>
                    </td>
                    <td>
                        <div class="tooltip">
                            <select class="dropdown" v-model="province.populationCenter" @click="preventPropagation" @change="onChanges" :disabled="!hasPermission">
                                <option v-for="populationCenter in availablePopulationCenter" :value="populationCenter">
                                    {{ populationCenter }}
                                </option>
                            </select>
                            <span class="tooltiptext">Population centers are settlements ranging from small thorpes to large metropolises. Each province can have one population center, which enables resource extraction.</span>
                        </div>
                    </td>
                    <td>
                        <div class="production-container">
                            <div class="tooltip">
                                <p class="production">+{{ calculateProvinceProduction(config, domain.realm, province) }}</p>
                                <span class="tooltiptext">Larger population centers generate more resources by effectively utilizing the land.</span>
                            </div>
                            <div class="tooltip">
                            <p class="upkeep">({{ calculateProvinceUpkeep(domain.realm, province) }})</p>
                                <span class="tooltiptext">Population centers require upkeep for maintenance, services, and salaries.</span>
                            </div>
                        </div>
                    </td>
                    <td>
                        <div class="tooltip">
                            <p>{{ calculateProvinceProfit(province) }}</p>
                            <span class="tooltiptext">Profit is calculated by subtracting the province's upkeep costs from its total revenue.</span>
                        </div>
                    </td>
                </tr>
            </table>
            <hr>
            <div  v-if="domain.realm.provinces.length > 0" class="tooltip modifier">
                <p>Production Bonus</p>
                <p class="production modifier-number" :style="{ 'color': productionModifier >= 0 ? 'var(--text-accent)': 'red'}">{{ productionModifier }}%</p>
                <span class="tooltiptext">Overall bonus granted by the civilization's traits and governance policies.</span>
            </div>
            <div  v-if="domain.realm.provinces.length > 0" class="tooltip modifier">
                <p>Upkeep Bonus</p>
                <p class="production modifier-number" :style="{ 'color': upkeepModifier >= 0 ? 'var(--text-accent)': 'red'}">{{ upkeepModifier }}%</p>
                <span class="tooltiptext">Overall bonus in upkeep costs provided by the civilization's traits and governance policies.</span>
            </div>
        </div>
        <button type="button" class="collapsible column" @click="openUnitCollapsible">
            <div class="label">
                <h3>Units</h3>
                <h3 class="number">({{ domain.units.length }})</h3>
            </div>
            <div class="sub-total">
                <div class="tooltip">
                    <h3 class="upkeep">{{ unitsUpkeep }}</h3>
                    <span class="tooltiptext">The sum of the upkeep of your units.</span>
                </div>
                <div class="caret">
                    <img v-if="showUnits" src="/caret-up.svg">
                    <img v-if="!showUnits" src="/caret-down.svg">
                </div>
            </div>
        </button>
        <div v-show="showUnits">
            <p v-if="domain.units.length === 0">To get started, recruit some units in the Military tab.</p>
            <table class="unit-table">
                <tr v-if="domain.units.length > 0">
                    <th>Name</th>
                    <th>Upkeep</th>
                </tr>
                <tr v-for="unit in domain.units">
                    <td>
                        <div class="tooltip">
                            <p>{{ unit.name }}</p>
                            <span class="tooltiptext">The name of the unit.</span>
                        </div>
                    </td>
                    <td>
                        <div class="tooltip">
                            <p>{{ unit.upkeep }}</p>
                            <span class="tooltiptext">The upkeep is 25% of its current total cost of the unit.</span>
                        </div>
                    </td>
                </tr>
            </table>
            <hr>
            <div v-if="domain.units.length > 0" class="tooltip modifier">
                <p>Unit Cost Reduction:</p>
                <p class="production modifier-number">{{ unitCostModifier }}%</p>
                <span class="tooltiptext">Overall bonus in unit costs provided by the civilization's traits and governance policies.</span>
            </div>
        </div>
    </div>
</template>

<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { utils } from '../../mixins/utils'

import BaseTab from './BaseTab.ts'
import OBR, { ContextMenuContext, Player } from '@owlbear-rodeo/sdk';
import { Heritage, Civilization, GoverningStyle, PopulationCenter, Province, Realm, Terrain, POPULATION_CENTER_UPKEEP, GOVERNING_STYLE_PRODUCTION_MODIFIER, HERITAGE_TERRAIN_MODIFIER, CIVILIZATION_PRODUCTION_MODIFIER, CIVILIZATION_POPULATION_CENTER_UPKEEP_MODIFIER, UNIT_COST_GOVERNING_STYLE_NOBLE_MODIFIER, UNIT_COST_CIVILIZATION_BARBARIC_MODIFIER, UNIT_COST_CIVILIZATION_NOMADIC_MODIFIER, Calendar } from '../../models/Realm.ts';
import { Config } from '../../models/Config.ts';
import { treasuryCalculator } from '../../mixins/treasuryCalculator.ts';

import Time from '../Time.vue';

const ID = "com.obr.domain-sheet/treasury"

const TREASURY_METADATA_KEY = ID + "/metadata";
const OWNER_METADATA_KEY = ID + "/owner";
const CALENDAR_METADATA_KEY = ID + "/calendar";

export default defineComponent({
    components: { Time },
    mixins: [utils, treasuryCalculator],
    extends: BaseTab,
    name: 'Treasury',
    props: {
        isGM: {
            type: Boolean,
            required: true
        },
        hasPermission: {
            type: Boolean,
            required: true
        },
        config: {
            type: Config,
            required: true
        },
        currentPlayer: {
            type: Object as PropType<Player>,
            required: true
        },
        players: {
            type: Array<Player>,
            required: true,
        }
    },
    data() {
        let sceneItemChangeCallback = () => {};
        let broadcastCallback = () => {};
        return {
            /** Collapsible */
            showProvinces: false,
            showUnits: false,

            /** Data Map */
            POPULATION_CENTER_UPKEEP,
            GOVERNING_STYLE_PRODUCTION_MODIFIER,
            HERITAGE_TERRAIN_MODIFIER,
            CIVILIZATION_PRODUCTION_MODIFIER,
            CIVILIZATION_POPULATION_CENTER_UPKEEP_MODIFIER,

            /** Enums */
            Terrain,
            Heritage,
            Civilization,
            GoverningStyle,
            PopulationCenter,

            /** Functions */
            sceneItemChangeCallback,
            broadcastCallback,
        }
    },
    created() {
        // If the previous load file did not contain the Realm, add it.
        if (!this.domain.realm) {
            this.domain.realm = new Realm();
        }
    },
    mounted() {
        const obrIntervalId = window.setInterval(async () => {
            if (OBR.isReady) {
                OBR.contextMenu.create(this.buildContextMenu());

                this.broadcastCallback = OBR.broadcast.onMessage(CALENDAR_METADATA_KEY, (event) => {
                    const before = this.domain.realm.calendar;
                    const after = JSON.parse(event.data as string) as Calendar;
                    const compare = this.compareCalendar(before, after);

                    if (compare == 0) {
                        return;
                    }

                    if (compare > 0) {
                        this.onChangeTimeEvent(true);
                    } else {
                        this.onChangeTimeEvent(false);
                    }
                });

                clearInterval(obrIntervalId);
            }
        }, 200);

        const sceneIntervalId = window.setInterval(async () => {
            const isReady = await OBR.scene.isReady();
            if (isReady) {
                this.sceneItemChangeCallback = OBR.scene.items.onChange((items) => {
                    if (this.config.sharedMode) {
                        return;
                    }

                    const drawings = items.filter((item) => item.layer == "DRAWING");

                    // Scan all of your province to make sure they still have that metadata tag, if not remove that province, another player claimed it.
                    let hasChanged = false;
                    for (let province of this.domain.realm.provinces) {

                        let found = false;
                        for (let drawing of drawings) {
                            if (drawing.metadata[OWNER_METADATA_KEY] === this.currentPlayer.id) {
                                found = true;
                                break;
                            }
                        }

                        if (!found) {
                            this.domain.realm.provinces = this.domain.realm.provinces.filter((x) => x.id !== province.id);
                            hasChanged = true;
                        }
                    }

                    if (hasChanged) {
                        this.updateRealm(this.domain.realm);
                    }
                });

                // Load the calendar from the Scene metadata.
                OBR.scene.getMetadata().then(metadata => {
                    if (metadata[CALENDAR_METADATA_KEY] == undefined) {
                        OBR.scene.setMetadata({
                            [CALENDAR_METADATA_KEY]: {
                                week: 1,
                                month: 1,
                                year: 1
                            } as Calendar
                        });
                    } else {
                        this.domain.realm.calendar = metadata[CALENDAR_METADATA_KEY] as Calendar;
                    }
                });

                clearInterval(sceneIntervalId);
            }
        }, 200);
    },
    unmounted() {
        this.sceneItemChangeCallback();
        this.broadcastCallback();
    },
    computed: {
        provinceProfits() {
            return this.calculateProvinceProfits(this.domain.realm.provinces);
        },
        unitsUpkeep() {
            return this.calculateUnitsUpkeep(this.domain.units);
        },
        productionModifier() {
            return this.getProvinceProductionModifier(this.domain.realm) * 100;
        },
        upkeepModifier() {
            return this.getProvinceUpkeepDiscount(this.domain.realm) * 100;
        },
        unitCostModifier() {
            let unitCostMod = 1;
            if (this.domain.realm.governingStyle == GoverningStyle.NOBLE) {
                unitCostMod *= UNIT_COST_GOVERNING_STYLE_NOBLE_MODIFIER;
            }

            if (this.domain.realm.civilization == Civilization.BARBARIC) {
                unitCostMod *= UNIT_COST_CIVILIZATION_BARBARIC_MODIFIER;
            }

            if (this.domain.realm.civilization == Civilization.NOMADIC) {
                unitCostMod *=  UNIT_COST_CIVILIZATION_NOMADIC_MODIFIER;
            }

            return Math.round((1 - unitCostMod) * 100);
        },
        forecast() {
            return this.calculateForecast(this.provinceProfits, this.unitsUpkeep);
        },
        /**
         * Compute what are the available population center based on the Kingdom's civilization
         */
        availablePopulationCenter() {
            let nomads = [PopulationCenter.SMALL_CAMP, PopulationCenter.MEDIUM_CAMP, PopulationCenter.LARGE_CAMP]
            if (this.domain.realm.civilization == Civilization.NOMADIC) {
                nomads.unshift(PopulationCenter.NONE);
                return nomads;
            }

            return Object.values(PopulationCenter).filter(
                (center) => !nomads.includes(center)
            );
        }
    },
    methods: {
        onTreasuryChanged($event: any) {
            const result = this.evaluateExpression($event.target.value, this.domain.realm.treasury);
            if (typeof(result) == 'number') {
                this.domain.realm.treasury = result as number;
                this.onUpdate();
            }
        },
        onTreasuryEnter($event: any) {
            if ($event.key === "Enter") {
                this.domain.realm.treasury = this.evaluateExpression($event.target.value, this.domain.realm.treasury);
            }
        },
        onChangeTimeEvent(forward: boolean) {
            if (forward) {
                let realm = this.addForecastToTreasury(this.domain.realm, this.forecast);
                realm = this.incrementTime(this.config, realm);
                this.domain.realm = realm;
                if (this.isGM) {
                    this.saveCalendar(this.domain.realm.calendar);
                    this.broadcastCalendar(this.domain.realm.calendar);
                }
            } else {
                let realm = this.removeFromTreasury(this.domain.realm);
                realm = this.deincrementTime(this.config, realm);
                this.domain.realm = realm;
                if (this.isGM) {
                    this.saveCalendar(this.domain.realm.calendar);
                    this.broadcastCalendar(this.domain.realm.calendar);
                }
            }

            this.onUpdate();
        },
        /**
         * Broadcast the calendar to the other players.
         * @param calendar The calendar
         */
        broadcastCalendar(calendar: Calendar) {
            OBR.broadcast.sendMessage(CALENDAR_METADATA_KEY, JSON.stringify(calendar), { destination: "REMOTE" });
        },
        /**
         * Save the calendar to the scene metadata
         * 
         * @param calendar the Calendar
         */
        saveCalendar(calendar: Calendar) {
            OBR.scene.setMetadata({
                    [CALENDAR_METADATA_KEY]: JSON.parse(JSON.stringify(calendar))
            });
        },
        onChanges() {
            this.onUpdate();
        },
        /**
         * Update the realm
         */
        updateRealm(_realm: Realm) {
            this.onUpdate();
        },
        /**
         * Add the province to the Realm
         * @param context
         */
        addProvinceToRealm(context: ContextMenuContext) {
            // Update the Hex in the scene.
            OBR.scene.items.updateItems(context.items, (items) => {
                for (let item of items) {
                    if (item.metadata[TREASURY_METADATA_KEY] === undefined) {
                        const province = new Province(item.id);
                        province.color = this.currentPlayer.color;
                        this.domain.realm.provinces.push(province);

                        item.style.fillColor = this.currentPlayer.color;
                        item.style.strokeColor = this.currentPlayer.color;
                        item.style.fillOpacity = 0.10;
                        item.style.strokeOpacity = 1;
                        item.metadata = {
                            [OWNER_METADATA_KEY]: this.currentPlayer.id
                        };
                    }

                    item.metadata[TREASURY_METADATA_KEY] = {
                        key: item.id
                    };
                }

                this.updateRealm(this.domain.realm);
            });
        },
        /**
         * Method to remove a provice from the realm when the user click on 'Remove Province' in the scene.
         * @param context The context
         */
        removeProvinceFromRealm(context: ContextMenuContext) {
            OBR.scene.items.updateItems(context.items, (items) => {
                for (let item of items) {
                    if (item.metadata[TREASURY_METADATA_KEY] !== undefined) {
                        this.domain.realm.provinces = this.domain.realm.provinces.filter((x: Province) =>
                            x.id !== item.id
                        );

                        item.style.fillColor = "#000000";
                        item.style.strokeColor = "#000000";
                        item.style.fillOpacity = 0.10;
                        item.style.strokeOpacity = 1;
                        item.metadata = {
                            [OWNER_METADATA_KEY]: undefined
                        };

                        delete item.metadata[TREASURY_METADATA_KEY];
                    }
                }

                this.updateRealm(this.domain.realm);
            });
        },
         /**
         * Event triggered whenever the context menu gets clicked.
         * @param context  The context menu context
         * @param _elementId The element
         */
        onContextMenuClick(context: ContextMenuContext, _elementId: string) {
            const addToRealm = context.items.every(
                (item) => item.metadata[TREASURY_METADATA_KEY] === this.player
            );
            if (addToRealm) {
                this.addProvinceToRealm(context);
            } else {
                this.removeProvinceFromRealm(context);
            }
        },
        /**
         * Build the context menu to be right-clicked.
         */
        buildContextMenu() {
            return {
                id: ID,
                icons: [
                    {
                        icon: "/pin.svg",
                        label: "Claim Province",
                        filter: {
                            every: [
                                { key: "visible", value: true },
                                { key: "layer", value: "DRAWING" },
                                { key: ["metadata", TREASURY_METADATA_KEY], value: undefined }
                            ]
                        }
                    },
                    {
                        icon: "/pin.svg",
                        label: "Remove Province",
                        filter: {
                            every: [
                                { key: "visible", value: true },
                                { key: "layer", value: "DRAWING" },
                            ]
                        }
                    }
                ],
                onClick: this.onContextMenuClick
            }
        },
        openProvinceCollapsible() {
            this.showProvinces = !this.showProvinces;
        },
        openUnitCollapsible() {
            this.showUnits = !this.showUnits;
        }
    }
})
</script>
  
<style scoped>

p {
   margin: 0;
}

.header {
    justify-content: space-around;
}

.province-table {
    width: 100%;
    margin: auto;
    display: inline-table;

    .production-container {
        display: inline-flex;
    }
}

.unit-table {
    width: 100%;
    margin: auto;
    display: inline-table;
}

.modifier {

    p {
        font-size: 0.75rem;
    }

    display: flex;
    justify-content: flex-end;

    .modifier-number {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
    }
}

.treasury-input {
    width: 100px;
    text-align: center;
    margin-left: 3.5rem;
}

.treasury-amount {
    margin: auto;
}

.treasury {
    justify-content: center;

    h3 {
        margin: 0;
        padding-left: 0.5rem;
    }
}

.production {
    color: var(--text-accent);
}

.upkeep {
    color: red;
    padding-left: 0.0625rem;
}

.collapsible {
    align-items: center;
    justify-content: space-between;
    margin-bottom: 0.5rem;
    margin-top: 0.5rem;

    .label {
        padding-left: 1rem;
        display: inline-flex;
        align-items: center;

        .number {
            margin-left: 0.25rem;
        }
    }

    .sub-total {
        display: inline-flex;
        align-items: center;

        .caret {
            filter: invert(80%) sepia(29%) saturate(6341%) hue-rotate(207deg) brightness(100%) contrast(102%);;
        }
    }
}

</style>